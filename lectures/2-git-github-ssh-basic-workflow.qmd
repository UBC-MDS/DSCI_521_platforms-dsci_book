---
title: Introduction to version control with Git and GitHub
jupyter: python3
---

## Learning outcomes

{{< include ../learning_objectives/lo-ch-02.qmd >}}

## Why version control?

![](img/phd101212s.png)

*source: “Piled Higher and Deeper” by Jorge Cham, http://www.phdcomics.com*

To **version control** a project, you need two main components: a version control system and a repository hosting service. *The version control system*, like Git, manages changes to the project, allowing you to share updates, receive contributions, and resolve conflicts. *A repository hosting service*, such as GitHub, stores your project online, facilitating remote access, collaboration, and distribution of your final product. While technically optional, using a hosting service offers significant advantages like access management, bug tracking, external contributions, and secure cloud backup. Given their benefits and the availability of free accounts, there are few reasons not to utilize a hosting service for your project.

## Setting Up and Remotely Accessing SSH Keys for Use with GitHub

Let's start with some definitions:

### Definitions

**Secure SHell (SSH) or `sh`** is a secure method commonly used for remotely logging into another computer. 

**The server** is the machine you are connecting to via SSH, which passively waits for incoming connections.

**The client** is usually your own machine, which initiates the contact with the server.

## What are some password-based authentication

Passwords are often short and relatively easy to guess or "break." For instance, consider a password with 12 characters, where each character can be one of 26 uppercase letters, 26 lowercase letters, 10 digits, or approximately 10 special characters. This results in around 70 possible choices per character, making the total number of possible combinations approximately $70^{12}\approx 10^{22}$. While this is an extraordinarily large number, patterns in password creation can make them more predictable and easier to guess. More detailed discussions on security and privacy will be covered in future courses.

## SSH key-based authentication

SSH key-based authentication involves two components: *a public key* and a *private key*. These keys have an asymmetrical relationship. *The public key* cannot decrypt messages that are encrypted using the *private key*. Conversely, the *private key* can decrypt messages that are encrypted using the *public key*. This setup ensures secure communication by allowing only the holder of the private key to access messages encrypted with the *public key*.

## Understanding public key private key concepts

- Think of a public key, not as a key, but as a padlock that you can make copies of and put anywhere you want.
- To put your ‘padlock’ on an another machine, you would copy it to `authorized_keys` in the `~/.ssh` folder.
- Think of a private key as an actual key, it can open the padlock that is stored on the other machine.

![](img/keys_1.png)

*source: http://blakesmith.me/2010/02/08/understanding-public-key-private-key-concepts.html*

## You can put your lock at many places

As long as you are using the same lock (public key),
you will be able to open it with the same private key.

![](img/keys_2.png)
*source: http://blakesmith.me/2010/02/08/understanding-public-key-private-key-concepts.html*

## How the lock works

- Keys are generated using `ssh-keygen`, to make private key (usually called `id_rsa`) and a public key (usually called `id_rsa.pub`)
- You can make copies of `id_rsa.pub` (public key/padlock) and distribute them to other machines
- The other machine uses the public key to encrypt a challenge message to you
- You need to show that you can decrypt the message to demonstrate that you are in possesion of the associated private key

## Why SSH keys over passwords

SSH keys use the [RSA cryptosystem](https://en.wikipedia.org/wiki/RSA_(cryptosystem))

The private key is much longer than a password. A standard now is 4096-bit keys, which means $> 10^{1200}$ possibilities. This makes it harder for a hacker to break (guess) the password. More on this when we discuss binary numbers next week.

Aside: Quantum computers will be able to break RSA encryption. It is very hard to predict whether this is years or decades away.

## Keeping your private key safe

- `ssh-keygen` allows you to put a password or passphrase on the private key
- this should be shared with NO ONE!
- if your private key does fall into the wrong hands, the person must still know the password or passphrase to use the private key

![](img/password_strength.png)
*source - https://xkcd.com/936/*

## Different type of keys

There may be different methods of how to generate private-public key pairs.

The [GitHub SSH key generation instructions](https://docs.github.com/en/authentication/connecting-to-github-with-ssh/generating-a-new-ssh-key-and-adding-it-to-the-ssh-agent) uses the `-t` flag to indicate the "type" of key to create,
in thier instructions they use the `ed25519` algorithm to create private and public values.

The general premice to SSH keys is the same, there is a private key that stays on your machine and is never shared with other people,
and the public key you can freely share that will be used to authenticate the machine with the private key on it.

### Authentication vs. encryption

* The system described above is purely for _authentication_
  * the client needs to prove to the server that the client is authorized to access the server
  * Someone with authority has put the public key in `~/.ssh/authorized_keys` on the server
  * The server now grants access to anyone possessing a private key matching one of these public keys

* This is separate from _encryption_ of the data flowing between the client and server.
  * This prevents eavesdroppers from listening to client-server communications

:::{.activity}
::::{.activity-header}
## Lecture 2 Activity 1
::::
::::{.activity-container}

## Creating a Repository

We can create a repository one of two ways:

1. Start on GitHub and **then** clone the repository to your local computer using Git.
2. Start in a folder on your local computer, use Git to initialize it as a Git repository (by typing `git init` inside the directory). **Then** create a new repository on GitHub without adding any files. **Then** use Git to tell your local computer where the remote is (i.e., the location of the empty GitHub repository on GitHub).

You can see the second method requires more work. So the first method is usually the most convenient and it is sufficient for you to only use this approach.

::::
:::

:::{.exercise}
::::{.exercise-header}
### Lecture 2 Activity 1
::::
::::{.exercise-container}

Check that your cloned repo it is a Git repository. How can you check that you are working on a Git repository?

Is a repository the same as a directory? Can be a Git repository your current working directory?

::::
:::

## Cloning repositories from GitHub

- If you only have minor edits to perform, you don't need to clone and can edit files directly on GitHub via their online editor.
- However, if you want to be able to run the code on your own machine, and modify it there, we need to "clone" the repository.
- To clone it:
    1. go into the repository
    2. click on the green "Clone or download" button (make sure the pop-up says "Clone with HTTPS")
        - note - we will learn to use SSH authentication later...
    3. copy the URL to the clipboard
    4. open Bash on your laptop
    5. navigate to the directory you want to clone into by using the `cd` command.
    6. type `git clone` followed by the URL, e.g. `git clone https://github.com/github_username/repository_name.git`, and press enter.
    7. Once the download has finished you can use `cd` to navigate into the directory you just clones and `ls` to confirm that the content is the same as you saw online.

For more details, see Github's docs on [cloning](https://help.github.com/articles/cloning-a-repository/).

**Be Careful**: do not nest git repositoies. That is, there should not be one git repository inside another git repositoiry.
Be careful that when you are using `git clone` (or `git init`

## Creating a repository from GitHub (method 1 above)

I recommend that you follow along with these steps on your own machine to practice the commands as you are reading about them.
If it is sometimes unclear where to click or what the output should look like from a command,
refer to the corresponding sections of the videos to see exactly what to do (The git workflow one and the ones from lecture 2).
You can create however many repositories on GitHub that you would like and remove them after,
so you don't need to worry about experimenting
and creating several new ones.

### Steps to follow:

1. Go to https://github.ubc.ca and make sure you are logged in.

2. Click green "New repository" button. Or, if you are on your own profile page, click on "Repositories", then click the green "New" button.

3. Enter a repository name
    - Choose between a public or private repo.
        - If you choose public, anyone can see and clone you repo (but it is still only you that can push to it).
    - Check "Initialize this repository with a README"
        - This makes it possible to clone the repo without adding a file manually later.

4. Click big green button "Create repository".

5. That's it! You now have a new repository on GitHub!

## What is a Git repository?

A Git repository stores all the necessary information
for version control your project in a hidden folder called `.git`.
If you want to know if you are working in a Git repo using the terminal
you can use the bash command `ls -a` as you can see in the image.
The `-a` flag will include into the lists of files
displayed on the terminal the hidden folders.
If `.git` is included you are working in a Git repository.

By cloning a repository from GitHub to your computer,
you are automatically getting a copy of `.git` and thus, working on a Git.

## Adding & committing changes to version controlled files

There are two ways to make changes to your files in the remote repo on GitHub:

1. Edit files directly on Github via the web interface.
    - Note that there is no step for adding to the staging area on GitHub. This gives less flexibility, but is convenient when working via the web interface where you probably only are making small changes.
2. Make changes on files you have cloned locally to your computer, `add` them to the staging area, `commit` and then `push` the changes up to Github.

Let's try out method 1 by editing the file called `README.md` that contains some basic information.

### Steps to follow:

1. Click on the `README.md` file link in your repo on GitHub.

2. Click on the pen tool (right-hand side of document)

3. Add your name as the author to the document (e.g., "author: Roald Dahl")

4. Provide a commit message (e.g. "Add author info").

5. Click on the big green button "Commit changes" to save your work (this is essentially `git add` + `git commit` in one click).

5. Download this repo to your local computer by cloning it (`git clone` + the remote's URL)

## Changing and saving version controlled files

- To make a change to a file inside a Git repository,
  edit it as you would with any other local file,
  e.g. `code name-of-file.txt`.

- Once you have made changes to a file in a local Git repository (such as on your laptop), you need to tell Git that you want to record these changes in the version history.

- This is a two step process where you first **add** the changes to the stanging area and then **committ** them, which saves the differences between the current and previous version of the file together with your message describing what you did.
    - These changes are saved in the hidden `.git` directory in the Git repository.

- This is what it looks like when adding and committing:

    1. Add changes to staging area

    `git add file-name(s)`

    2. Commit the changes together with a descriptive message

    `git commit -m "Clarify the README installation instructions"`

For more details, see Software Carpentry's lesson on [tracking local changes with Git](http://swcarpentry.github.io/git-novice/04-changes/).

### What is the staging area, and why is it there?

![](img/staging_area.png)

Once you reach a point that you want Git
to keep a record of the current version of your work,
you need to commit (i.e., snapshot) your changes.
A prerequisite to this is telling Git which files
should be included in that snapshot.
We call this step adding the files to the **staging area**.

Note that the staging area is not a real physical location on your computer;
 it is instead a conceptual placeholder for these files until they are committed.
 The benefit of the Git version control system using a staging area is
 that you can choose to commit changes in only certain files.
 For example, we add only the two files that are important
 to the analysis project (`analysis.ipynb` and `README.md`) and
  not our personal scratch notes for the project (`notes.txt`).

The staging area allows more control over what you are about to commit,
allowing you to commit parts of a file or multiple files together
with a single descriptive message.
To add parts of a file instead of everything type `git add -p`
and then interactively choose which parts you want by typing either `n` (no)
or `y` (yes) followed by pressing enter for each chunk of code.
This workflow is great for reviewing the changes as you add them
to the staging area,
which ensures you don't commit anything by mistake.
Note that you must omit`-p`
when adding new files,
so you would type `git add <filename>`.

**Commands**

To add all updated, new, and deleted files in the git repo you can type `git add --all`.
To only add all updated and new files in the git repo you can type `git add .`.
To only add all updated and deleted files in the git repo you can type `git add -u`,
this is very useful.

To see which files you have staged, before committing them,
you can use `git status`.
To see the exact changes you have staged instead of just the file names,
use `git diff --staged`.
Finally,
if you change your mind and want to removea file from the staging area,
you can type `git restore --staged name-of-your-file.txt`

## Commit your files

To include a description in your commit using the terminal,
you should write the command `git commit` and press ENTER.
After doing that, a file called `COMMIT_EDITMSG` will open in your editor.
There you can write the title and body of the commit message
that you want to associate with your changes.


## Push local changes to GitHub

Once you have committed, you changes are saved locally on your laptop.
To also upload them to GitHub, you need to "push" the changes to Github.
Since you cloned an online repository at the beginning,
git knowed that you want to push you changes to that location by default,
and you can do so by typing `git push` without specifyin a URL.

For more details, see Github's doc on [pushing changes to Github](https://help.github.com/articles/pushing-to-a-remote/).

**Always verify that your assignments were uploaded by viewing the online repo!**

## Pull your changes from a remote repository

Changes pushed by collaborators, or created directly on GitHub
will not be automatically sent to your local repository.

If you are working on a project with collaborators,
they will also be making changes to files (e.g., to the analysis code in a Jupyter notebook and the project’s `README` file),
committing them to their own local repository, and pushing their commits to the remote GitHub repository
to share them with you. When they push their changes, those changes will only initially exist
in the remote GitHub repository and not in your local repository.

To obtain the new changes from the remote repository on GitHub,
you will need to pull those changes to your own local repository.
By pulling changes, you synchronize your local repository to what is present on GitHub.
Additionally, until you pull changes from the remote repository, you will not be able
to push any more changes yourself (though you will still be able to work and make commits in your own local repository)

If you want to do this with the terminal,
you have to pull from the terminal you should use the command `git pull`.


:::{.exercise}
::::{.exercise-header}
### Lecture 2 Exercise 2
::::
::::{.exercise-container}

Let's access your own GitHub home for MDS. There you can find the links for all the courses' repositories, as well as, the labs' repositories. Your home is located at:

```https://github.ubc.ca/MDS-2021-22/yourCWL_home```

where `yourCWL` should be replaced by your CWL.

(**Hint:** you might want to bookmark this page as it gives you easy access to all relevant courses' repositories).

::::
:::


:::{.exercise}
::::{.exercise-header}
### Lecture 2 Exercise 2
::::
::::{.exercise-container}

- [Create a new repository at GitHub.com](https://docs.github.com/en/github/creating-cloning-and-archiving-repositories/creating-a-new-repository) and choose to add a README file in this process.
- Clone this repository (note that you will need to change your username on your computer if you use a different one than for GitHub.ubc.ca).
- Make changes to the README.
- Add and commit your changes
- Create a new file, add and commit it
- Push your previous changes to GitHub and confirm that they are there.

::::
:::



## Attribution
1. [Happy Git and GitHub for the useR by Jenny Bryan and the STAT 545 TAs](http://happygitwithr.com/)
2. [Software Carpentry](https://software-carpentry.org/), specifically the Unix Shell and Git lessons

